#!/usr/bin/env python3
"""
Manage notes using the gitjournal.io notes format

Todo:
    - [x] Parse note file to return a header dictionary and a markdown body
    - [x] Convert normal text file to markdown with yaml header
        - [x] Add modified date based on file modified date
        - [x] Add created date based on file created date
        - [x] Add title based on file title
    - [ ] Convert all files in a folder to new format
    - [ ] Add tags header and option to add tags at create
    - [ ] Add images to a folder for linking
    - [ ] Preserve note dates based on metadata
    - [ ] Migrate notes to new format
    - [ ] Create new note
        - [ ] Add metadata options via the command line similar to docker env (-e)
          additions.
        - [ ] Add tags via the command line using -t

"""
import re
import os
import json
import yaml
import time
from datetime import datetime
import pytz
from pathlib import Path

DIR = os.path.expanduser('~/notes')
EXTENSION = 'md'
FILENAME_PATTERNS = ('*.txt','*.md')

def get_files(dirpath, extensions):
    """Gets all files with given extension"""
    rtn = []
    for ext in extensions:
        rtn.extend(Path(dirpath).glob(ext))
    return rtn

def has_metadata(body):
   return body.startswith('---')

def parse(text):
    meta = {}
    body = text
    if has_metadata(text):
        p = re.compile('---\n(.*?)\n---\n(.*)', flags=re.DOTALL)
        p.search(text).groups()
        (meta, body) = text.split('---\n', 2)[1:]
        return (yaml.load(meta,Loader=yaml.FullLoader), body.strip())
    else:
        return (meta, body)

def metadata_to_json(metadata):
    return json.dumps(metadata)

def create_metadata_from_file(filepath):
    p = Path(filepath)
    stat = p.stat()
    return {
        'created': datetime.utcfromtimestamp(stat.st_ctime).replace(tzinfo=pytz.UTC).replace(microsecond=0),
        'modified': datetime.utcfromtimestamp(stat.st_mtime).replace(tzinfo=pytz.UTC).replace(microsecond=0),
        'title': p.stem,
    }

def fetch(path):
    with open(path,'r') as f:
        return f.read()

def read(path):
    text = fetch(path)
    return parse(text)

def get_all_notes(order_by='modified', reverse=True):
    """List all notes by last modified date"""

    rows = []
    notes = get_files(DIR, FILENAME_PATTERNS)
    for npath in notes:
        stat = npath.stat()
        rows.append({
            'path':str(npath),
            'title':str(npath.stem),
            'created_timestamp':stat.st_ctime,
            'created_iso':datetime.utcfromtimestamp(stat.st_ctime).replace(tzinfo=pytz.UTC).isoformat(),
            'modified_timestamp':stat.st_mtime,
            'modified_iso':datetime.utcfromtimestamp(stat.st_mtime).replace(tzinfo=pytz.UTC).isoformat()
        })
    rows.sort(key=lambda x: x['modified_timestamp'], reverse=True)
    return rows

def create_metadata(options):
    metadata = {
        'created': datetime.utcnow().replace(tzinfo=pytz.UTC).replace(microsecond=0),
        'modified': datetime.utcnow().replace(tzinfo=pytz.UTC).replace(microsecond=0),
    }
    return { **metadata, **options }

def create(options):
    text = ''
    metadata = create_metadata(options)
    filename = '%s.%s' % (metadata['created'].isoformat(), EXTENSION)
    filepath = os.path.join(DIR,filename)

def render(metadata,text):
    header = yaml.dump(metadata)
    header = "---\n%s---\n" % header
    return "%s\n%s" % (header,text)

def reformat_all():
    '''Reformats all note documents while maintaining modified date'''
    notes = get_all_notes()
    paths = []
    for note in notes:
        filepath = note['path']
        paths.append(reformat(filepath))
    return paths

def reformat(filepath):
    '''
    Updates the note to the current document format.

    Steps:
    - Loads a exisitng note
    - Rebuilds metadata
    - Render yaml and markdown as plaintext
    - Overwrite the file while maintining created and modified dates
    '''
    path = Path(filepath)
    stat = path.stat()
    metadata, text = read(filepath)
    metadata = {**create_metadata_from_file(filepath), **metadata}
    ctime = stat.st_ctime <= stat.st_mtime and stat.st_ctime or stat.st_mtime
    return write(filepath, metadata, text, ctime=ctime, mtime=stat.st_mtime)

def write(filepath, metadata, text, ctime=None, mtime=None):
    '''
    Renders a note document and writes it to the notes directory. Optionally
    a created and modified timestamp can be sent to preserve or modify the file
    dates.
    '''
    with open(filepath, 'w') as file_pointer:
        file_pointer.write(render(metadata, text))

    # Update local file dates
    if ctime and mtime:
        os.utime(filepath, (ctime, mtime))

    return filepath

if __name__ == '__main__':
    paths = reformat_all()
    print("Reformat complete: %s notes were reformatted" % len(paths))

    '''
    for note in notes:
        path = note['path']
        metadata, txt = read(path)
        if not metadata:
            metadata = create_metadata_from_file(path)

        rtn = {}
        rtn['path'] = note['path']
        rtn['metadata'] = metadata
        print(yaml.dump(rtn))

    #filepath = notes[-1]['path']
    #filepath = notes[20]['path']
    filepath = os.path.join(DIR,'jcinis-14117.md')
    metadata, text = read(filepath)
    if not metadata:
        metadata = create_metadata_from_file(filepath)

    newpath = filepath+".new.txt"
    write(newpath,metadata,text)
    print(render(metadata,text))
    '''

    '''
    note = get_note(filepath)
    metadata = metadata_from_file(filepath)
    metadata['tags'] = ['journal','your mom']
    metadata_json = metadata_to_json(metadata)
    print(metadata_json)
    print(json.dumps(note))
    note = (metadata,note[1])
    print(output(*note))
    '''
